#################
#CURRENT CHANGES#
#################

#TEMPORARY#
-view transformation matrix uniform
-view transformation normal matrix uniform
-camera position uniform
-turntable style camera
-dials rotate camera now (pitch / yaw / roll)

#####################
#CHANGES IN OPENGL 3#
#####################

	############
	#ANIMATIONS#
	############

	For the animation we added two classes. Both classes see animations as a series of commands. Each command is a gradient of the transformation matrix, added to it to get a desired change.

	The first class, named "animation", explicitly scripts said gradients. In "animation" an animation is seen as a list of said commands, where every command also has a duration (number of discrete time-steps or number of times it is added to the transition matrix, before proceeding to the next command). These commands can be added mainly with two methods, which are "go" and "rotate", the first one adds a gradient to the translation part of the transformation matrix, and the latter to the rotation part. An example of a scripted animation could be "go farward in x direction, turn 90 degreess, go farward in z direction...". These scripts are implemented in the "initAnimations" method of the class "mainview".

	Then a second (possibly series of) class can be found in the "parametricAnimation.h" file. Here we define all those animation which whose commands don't have to be listed expicitly, but can be computed (they are parametric function). For now we just implemented an orbital (elliptical) movement. This is done by taking the parametric definition of the ellipse on a 2D plane (u = a*cos(t), v = b*sin(t)), and then 2 axis (and an origin) in R3, defining a plane (on which the ellipse is). Therefore u and v are used to compute the linear combination u*axis1 + v*axis2, and then O is added (for translation). There is also a method to update O. This method can be fed with the parametric function of another orbital animation, having an orbit arround an orbiting object.

	#######
	#WAVES#
	#######

	For the second part of the assignment we added two new shaders (fragshader_wave and vertshader_wave), for the waves animation. These have been implemented as required by the assignment (please look at the commented glsl files).

	We then finally added a time counter (so that the wave phases changes with time), and the uniforms for the wave values, as well as definitions and passages of these values in the c++ code, more precisely in the "paintGL" method of the "mainview" class.
	
	####
	#PS#
        ####
        
        For the wave screenshots, CULLING was deactivated
	
#####################
#CHANGES IN OPENGL 2#
#####################

First two new classes have been added. The first one is the class "solid_mesh". This class wraps an entire mesh. In fact it stores the size of the mes (number of vertices), its VAO, its VBO, and its transformation.
It also has some useful method, mainly "getNormalMatrix", which returns the QMAtrix3x3 which is the normal matrix w.r.t. the mesh transformation.

The second class added is "shaderwrapper", as we will be using multiple shader, it is useful to wrapp them, along with their uniform locations.

As some function to send data to the shader or to allocate a VBO or VAO, are methods of the class "QOpenGLFunctions_3_3_Core", we leave these duty to the class "mainview".
We in fact added so methods to mainview to set the VAO and VBO of a mesh, render them (given a mesh), and destroy a mesh.
In addition to this the method "createShaderProgram" has been modified so that it makes use of the "shaderwrapper" class.

A variable has been added to "mainview", to keep track of the current shader and the function "getShader" has been made so that a pointer to the current shader is returned.

There are now 6 glsl shader programs, for 3 different shader (2 for each, fragment and vertex). These are normal shader (using normal as color), phong shading, and gouraud shading.

The vertex struct (in "geoms.h"), has been modified so that it also includes texture mapping.
A third location has been added in the shaders for this vec2.
We also added a variable to "mainview" to keep track of the generated texture ("tex"), and modified "initializeGL" so that the texture is generated and bind.
This is done right before uploading the texture image (to do so, the method "imageToBytes" has been added to the "mainview" class).

Moreover in "paintGl" we also bind the texture before rendering.

At last i the class "model", "unitize" was implemented.



############################################
#EXPERIMENT WITH DIFFERENT WRAPPING METHODS#
############################################

	##################
	#WRAPPING METHODS#
	##################

	Regarding wrapping methods, first of all the difference between "GL_TEXTURE_WRAP_T" and "GL_TEXTURE_WRAP_S", is that the specified method is applied along the "t" direction (the vertical axes of the 2D texture) or the "s" direction (the horizontal one).

	Now the main difference between the methods can be seen when one of the specified (s,t) coordinates is outised of the texture bound. This is why we multiplied each (s,t) pair by a factor of 2, because otherwise, in this case, with texture mapping properly done, there is no difference.

	We can see however that, in "t" direction, "GL_CALMP_TO_BORDER", "GL_CLAMP_TO_EDGE", and "GL_REPEAT", have the same exact texture mapping in the back and the front of the cat. The difference is in the middle part of the body. This because, if we look at the 2D texture, face and back, if multiplied by 2, the height is less than that of the picture. The parts which differ between the three methods are those which are closer to the top than the bottom of the 2D texture (the distance from the top is less that "t", thus double it is more than 1). "GL_REPEAT" will threat the 2D texture as a sort of toroidal surface, basically starting from the bottom once the top (1) is surpassed. We can in fact see that the middle part of the cat here is filled. "GL_CLAMP_TO_BORDER" will instead set these values (those outside the bound in the "t" direction in this case), are set to the color "black" (in this case). While   "GL_CLAMP_TO_EDGE" sets the "t" coordinate to the closest vertical boundary, and the color is the determined as usual (only at the edges of the texture). Therefore, if the value is greather than the maximum "t", then there is an array of possible pixel it can be assigned to, made of the top edge of the texture. The "s" coordinate then determines which along the colors on the borders is picked.
	Finally the "GL_MIRRORED_REPEAT", when one edge is surpassed, instead of starting from the opposite one (like in "GL_REPEAT"), it goes back (in the opposite direction), starting from the same edge that was surpassed. Informally we might say it bounces off.

	When these methods are set for "GL_TEXTURE_WRAP_S", the same exact thing happens, only horizontally with respect to the 2D texture.

	###################
	#FILTERING METHODS#
	###################

	When the texture filtering is set to GL_NEAREST, every pixel's texture color is set to the color of the texel that is closest to the texture coordinates of that pixel. This means that when the texture is scaled up, there is a sharp line between two pixels. If it's set to GL_LINEAR, the color will be interpolated between the texels of the texture, which means there is a smooth transition between pixels.
	There are other modes for GL_TEXTURE_MIN_FILTER that can be used if mipmaps are utilized.


#####################
#CHANGES IN OPNEGL 1#
#####################
First we added some new types (in "geoms.h"), defining both basic geometrical components (RGB color, points and vertices), and polygons (triangles in 3D, pyramids and cubes). In the file "geoms.cpp" functions to easily (and especially in 1 row) generate the struct representing instances of these polynoms, are specified.

Then we added a new class "transform", to store (and easily change) a tranformation's rotation angles, translation (with respect to x,y, and z axis), and uniform scaling. This class is then also able to return a QMatrix4x4 which computes the aforementioned tranformation.

At last in "colors.h" some constants for RGB colors have been defined.

Then in the "mainview.h" file, in the mainview class declaration, we added some private arguments string the solid's tranformations, the VBOs and VAOs of the rendered objects, and the model and projection tranformation's uniform's location. At last in te "mainview.cpp" file we modified the "initializeGL" method, so that at the end it would compute the vertices of the sphere, pyramid, and cube, their respective VAOs and VBOs, store said vertices in their VBOs, and define the attributes of position and color in the VAO.
The "createShaderProgram" method was also modified so that at the end the location of the model and projection transformation uniform would be stored. The "paintGL" method was was changed so that it would also render the cube, triangle and sphere (with relative tranformations). At last, the methods "resizeGl", "setScale", and "serRotation" were modified to respectively update projection tranformation (according to window's size), update scaling of object's tranformation, and updating rotation of object's tranformation.
